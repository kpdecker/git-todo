#!/usr/bin/env node

var _ = require('underscore'),
    async = require('async'),
    colors = require('colors'),
    github = require('../lib/github-scan'),
    local = require('../lib/local-scan'),
    optimist = require('optimist');

var mergedInfo = {};

var argv = optimist
    .usage('Scan scans local git repos and github for outstanding code\nUsage $0 [--config configFile] [--html] dirs')
    .demand('c')
    .alias('c', 'config')
    .default('c', getUserHome() + '/.config/git-todo')
    .boolean('h')
    .alias('h', 'html')
    .argv;

if (argv.html) {
  colors.mode = 'browser';
} else if (!process.stdout.isTTY) {
  colors.mode = 'none';
}

async.parallel([
  function(callback) {
    var config = argv.config;
    config = config.replace(/^~\//, getUserHome() + '/');

    github(require(config), handler(callback));
  },
  function(callback) {
    var dirs = argv._.join(' ');
    local(dirs, handler(callback));
  }
],
function() {
  var outputCount = 0;

  _.each(_.keys(mergedInfo).sort(), function(name) {
    var status = mergedInfo[name],
        buffer = '';

    var NEWLINE = argv.html ? '<br>\n' : '\n';

    if (!status.remote) {
      buffer += '  no-remote\n'.yellow + NEWLINE;
    }
    if (status.localBranch) {
      buffer += '  local-only-branch: '.yellow + status.branch + NEWLINE;
    }
    if (status.ahead) {
      buffer += '  ahead:  '.yellow + status.ahead + NEWLINE;
    }
    if (status.behind) {
      buffer += '  behind: '.yellow + status.behind + NEWLINE;
    }
    if (status.stashes) {
      buffer += '  stash:  '.yellow + status.stashes + NEWLINE;
    }
    if (status.issues) {
      buffer += '  issues: '.yellow + status.issues + NEWLINE;
    }
    if (status.unmergedBranches) {
      var localOnlyBranches = _.filter(status.unmergedBranches, function(branch) { return branch.localBranch; }).length,
          aheadBranches = _.filter(status.unmergedBranches, function(branch) { return branch.ahead; }).length,
          unmerged = _.keys(status.unmergedBranches).length - localOnlyBranches - aheadBranches;

      header('Branch Status');

      if (unmerged) {
        buffer += '    unmerged:   '.yellow + unmerged + NEWLINE;
      }
      if (localOnlyBranches) {
        buffer += '    local-only: '.yellow + localOnlyBranches + NEWLINE;
      }
      if (aheadBranches) {
        buffer += '    ahead:      '.yellow + aheadBranches + NEWLINE;
      }
    }

    if (status.commits) {
      header('Commits since version');
      list(status.commits.map(function(commit) {
          return column(commit.sha, 6).yellow + ' : '
              + column(commit.message.replace(/\s/g, ' '), 50)
              + ' (@' + commit.committer + ')';
        })
        .map(listItem)
        .join('\n'));
    }
    if (status.pulls) {
      header('Open pull requests');
      list(_.map(status.pulls, function(pull) {
          return column('#' + pull.number, 6).yellow
              + ' : ' + column(pull.message, 50)
              + ' (@' + pull.committer + ')';
        })
        .map(listItem)
        .join('\n'));
    }
    if (status.status) {
      var fileStatus = _.chain(status.status)
        .map(function(count, name) {
          if (count) {
            return column(name + ':', 10).yellow + ' '.yellow + count;
          }
        })
        .compact()
        .map(listItem)
        .join('\n')
        .value();

      if (fileStatus) {
        header('File Status');
        list(fileStatus);
      }
    }

    if (buffer) {
      outputCount++;

      if (argv.html) {
        console.log('<h2>' + status.name.blue + ': ' + (status.latest || '') + '</h2>');
      } else {
        console.log(status.name.blue + ': ' + (status.latest || ''));
      }
      if (status.path) {
        console.log('    ' + status.path + (argv.html ? '<br>' : ''));
      }
      console.log(buffer);
      console.log(argv.html ? '<br>' : '');
    }


    function header(text) {
      if (buffer) {
        buffer += '\n';
      }
      if (argv.html) {
        buffer += '<h3>' + text + '</h3>\n';
      } else {
        buffer += '  ' + text + ':\n';
      }
    }
    function list(content) {
      if (argv.html) {
        buffer += '<ul>\n' + content + '\n</ul>\n';
      } else {
        buffer += content + '\n';
      }
    }
    function listItem(content) {
      if (argv.html) {
        return '     <li>' + content + '</li>';
      } else {
        return '     ' + content;
      }
    }
  });

  if (outputCount) {
    console.log(outputCount + ' repositories with TODOs');
  }
});

function column(str, len) {
  str = str.substr(0, len);
  str += new Array(len + 1 - str.length).join(' ');
  return str;
}

function handler(callback) {
  return function(err, repos) {
    if (err) {
      console.log(err);
      throw err;
    }

    _.each(repos, function(info, name) {
      _.extend(mergedInfo[name] = mergedInfo[name] || {}, info);
    });

    callback();
  };
}

// http://stackoverflow.com/questions/9080085/node-js-find-home-directory-in-platform-agnostic-way
function getUserHome() {
  return process.env[(process.platform == 'win32') ? 'USERPROFILE' : 'HOME'];
}
