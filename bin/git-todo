#!/usr/bin/env node

var _ = require('underscore'),
    async = require('async'),
    github = require('../lib/github-scan'),
    local = require('../lib/local-scan'),
    optimist = require('optimist');

require('colors');

var mergedInfo = {};

var argv = optimist
    .usage('Scan scans local git repos and github for outstanding code\nUsage $0 [--config configFile] dirs')
    .demand('c')
    .alias('c', 'config')
    .default('c', getUserHome() + '/.config/git-todo')
    .argv;

async.parallel([
  function(callback) {
    var config = argv.config;
    config = config.replace(/^~\//, getUserHome() + '/');

    github(require(config), handler(callback));
  },
  function(callback) {
    var dirs = argv._.join(' ');
    local(dirs, handler(callback));
  }
],
function() {
  var outputCount = 0;

  _.each(_.keys(mergedInfo).sort(), function(name) {
    var status = mergedInfo[name],
        buffer = '';

    if (!status.remote) {
      buffer += '  no-remote\n'.yellow;
    }
    if (status.localBranch) {
      buffer += '  local-only-branch: '.yellow + status.branch + '\n';
    }
    if (status.ahead) {
      buffer += '  ahead:  '.yellow + status.ahead + '\n';
    }
    if (status.behind) {
      buffer += '  behind: '.yellow + status.behind + '\n';
    }
    if (status.stashes) {
      buffer += '  stash:  '.yellow + status.stashes + '\n';
    }
    if (status.issues) {
      buffer += '  issues: '.yellow + status.issues + '\n';
    }
    if (status.unmergedBranches) {
      if (buffer) {
        buffer += '\n';
      }
      var localOnlyBranches = _.filter(status.unmergedBranches, function(branch) { return branch.localBranch; }).length,
          aheadBranches = _.filter(status.unmergedBranches, function(branch) { return branch.ahead; }).length,
          unmerged = _.keys(status.unmergedBranches).length - localOnlyBranches - aheadBranches;

      buffer += '  Branch Status:\n';

      if (unmerged) {
        buffer += '    unmerged:   '.yellow + unmerged + '\n';
      }
      if (localOnlyBranches) {
        buffer += '    local-only: '.yellow + localOnlyBranches + '\n';
      }
      if (aheadBranches) {
        buffer += '    ahead:      '.yellow + aheadBranches + '\n';
      }
    }

    if (status.commits) {
      if (buffer) {
        buffer += '\n';
      }
      buffer += '  Commits since version:\n';
      buffer += status.commits.map(function(commit) {
        return '    ' + column(commit.sha, 6).yellow + ' : '
            + column(commit.message.replace(/\s/g, ' '), 50)
            + ' (@' + commit.committer + ')';
      }).join('\n');
      buffer += '\n';
    }
    if (status.pulls) {
      if (buffer) {
        buffer += '\n';
      }
      buffer += '  Open pull requests:\n';
      buffer +=  _.map(status.pulls, function(pull) {
        return '    ' + column('#' + pull.number, 6).yellow
            + ' : ' + column(pull.message, 50)
            + ' (@' + pull.committer + ')';
      }).join('\n');
      buffer += '\n';
    }
    if (status.status) {
      var fileStatus = _.chain(status.status)
        .map(function(count, name) {
          if (count) {
            return '    ' + column(name + ':', 10).yellow + ' '.yellow + count;
          }
        })
        .compact()
        .join('\n')
        .value();

      if (fileStatus) {
        if (buffer) {
          buffer += '\n';
        }
        buffer += '  File Status:\n' + fileStatus + '\n';
      }
    }

    if (buffer) {
      outputCount++;

      console.log(status.name.blue + ': ' + (status.latest || ''));
      console.log('    ' + status.path);
      console.log(buffer);
      console.log();
    }
  });

  if (outputCount) {
    console.log(outputCount + ' repositories with TODOs');
  }
});

function column(str, len) {
  str = str.substr(0, len);
  str += new Array(len + 1 - str.length).join(' ');
  return str;
}

function handler(callback) {
  return function(err, repos) {
    if (err) {
      console.log(err);
      throw err;
    }

    _.each(repos, function(info, name) {
      _.extend(mergedInfo[name] = mergedInfo[name] || {}, info);
    });

    callback();
  };
}

// http://stackoverflow.com/questions/9080085/node-js-find-home-directory-in-platform-agnostic-way
function getUserHome() {
  return process.env[(process.platform == 'win32') ? 'USERPROFILE' : 'HOME'];
}
